module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 15);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("bn.js");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/regenerator");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/http-helpers");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("web3-utils");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/asyncToGenerator");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/eccrypto");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/typeof");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("elliptic");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("memory-cache");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("loglevel");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("json-stable-stringify");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "@babel/runtime/regenerator"
var regenerator_ = __webpack_require__(1);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(6);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/typeof"
var typeof_ = __webpack_require__(8);
var typeof_default = /*#__PURE__*/__webpack_require__.n(typeof_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/asyncToGenerator"
var asyncToGenerator_ = __webpack_require__(4);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/classCallCheck"
var classCallCheck_ = __webpack_require__(9);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/createClass"
var createClass_ = __webpack_require__(10);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass_);

// EXTERNAL MODULE: external "@toruslabs/eccrypto"
var eccrypto_ = __webpack_require__(5);

// EXTERNAL MODULE: external "@toruslabs/http-helpers"
var http_helpers_ = __webpack_require__(2);

// EXTERNAL MODULE: external "bn.js"
var external_bn_js_ = __webpack_require__(0);
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_);

// EXTERNAL MODULE: external "elliptic"
var external_elliptic_ = __webpack_require__(11);

// EXTERNAL MODULE: external "memory-cache"
var external_memory_cache_ = __webpack_require__(12);
var external_memory_cache_default = /*#__PURE__*/__webpack_require__.n(external_memory_cache_);

// EXTERNAL MODULE: external "web3-utils"
var external_web3_utils_ = __webpack_require__(3);

// CONCATENATED MODULE: ./src/httpHelpers.js

// EXTERNAL MODULE: external "loglevel"
var external_loglevel_ = __webpack_require__(13);
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_);

// CONCATENATED MODULE: ./src/loglevel.js

/* harmony default export */ var loglevel = (external_loglevel_default.a.getLogger('torus.js'));
// CONCATENATED MODULE: ./src/some.js
var Some = function Some(promises, predicate) {
  return new Promise(function (resolve, reject) {
    var finishedCount = 0;
    var sharedState = {
      resolved: false
    };
    var errorArr = new Array(promises.length).fill(undefined);
    var resultArr = new Array(promises.length).fill(undefined);
    var predicateError;
    promises.forEach(function (x, index) {
      x.then(function (resp) {
        resultArr[index] = resp;
        return undefined;
      })["catch"](function (error) {
        errorArr[index] = error;
      })["finally"](function () {
        if (sharedState.resolved) return;
        predicate(resultArr.slice(0), sharedState).then(function (data) {
          sharedState.resolved = true;
          resolve(data);
          return undefined;
        })["catch"](function (error) {
          // log only the last predicate error
          predicateError = error;
        })["finally"](function (_) {
          finishedCount += 1;

          if (finishedCount === promises.length) {
            reject(new Error("Unable to resolve enough promises, errors: ".concat(JSON.stringify(errorArr), ", responses: ").concat(JSON.stringify(resultArr), ", predicate: ").concat(predicateError.message || predicateError)));
          }
        });
      });
    });
  });
};
// EXTERNAL MODULE: external "@babel/runtime/helpers/toConsumableArray"
var toConsumableArray_ = __webpack_require__(7);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray_);

// EXTERNAL MODULE: external "json-stable-stringify"
var external_json_stable_stringify_ = __webpack_require__(14);
var external_json_stable_stringify_default = /*#__PURE__*/__webpack_require__.n(external_json_stable_stringify_);

// CONCATENATED MODULE: ./src/utils.js



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var utils_kCombinations = function kCombinations(s, k) {
  var set = s;

  if (typeof set === 'number') {
    set = Array.from({
      length: set
    }, function (_, i) {
      return i;
    });
  }

  if (k > set.length || k <= 0) {
    return [];
  }

  if (k === set.length) {
    return [set];
  }

  if (k === 1) {
    return set.reduce(function (acc, cur) {
      return [].concat(toConsumableArray_default()(acc), [[cur]]);
    }, []);
  }

  var combs = [];
  var tailCombs = [];

  for (var i = 0; i <= set.length - k + 1; i += 1) {
    tailCombs = kCombinations(set.slice(i + 1), k - 1);

    for (var j = 0; j < tailCombs.length; j += 1) {
      combs.push([set[i]].concat(toConsumableArray_default()(tailCombs[j])));
    }
  }

  return combs;
};
var utils_thresholdSame = function thresholdSame(arr, t) {
  var hashMap = {};

  for (var i = 0; i < arr.length; i += 1) {
    var str = external_json_stable_stringify_default()(arr[i]);
    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;

    if (hashMap[str] === t) {
      return arr[i];
    }
  }

  return undefined;
};
var utils_keyLookup = function keyLookup(endpoints, verifier, verifierId) {
  var lookupPromises = endpoints.map(function (x) {
    return Object(http_helpers_["post"])(x, Object(http_helpers_["generateJsonRPCObject"])('VerifierLookupRequest', {
      verifier: verifier,
      verifier_id: verifierId.toString()
    }))["catch"](function (_) {
      return undefined;
    });
  });
  return Some(lookupPromises, function (lookupResults) {
    var lookupShares = lookupResults.filter(function (x) {
      return x;
    });
    var errorResult = utils_thresholdSame(lookupShares.map(function (x) {
      return x && x.error;
    }), ~~(endpoints.length / 2) + 1);
    var keyResult = utils_thresholdSame(lookupShares.map(function (x) {
      return x && x.result;
    }), ~~(endpoints.length / 2) + 1);

    if (keyResult || errorResult) {
      return Promise.resolve({
        keyResult: keyResult,
        errorResult: errorResult
      });
    }

    return Promise.reject(new Error('invalid'));
  })["catch"](function (_) {
    return undefined;
  });
};
var utils_keyAssign = function keyAssign(endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId) {
  var nodeNum;
  var initialPoint;

  if (lastPoint === undefined) {
    nodeNum = Math.floor(Math.random() * endpoints.length);
    initialPoint = nodeNum;
  } else {
    nodeNum = lastPoint % endpoints.length;
  }

  if (nodeNum === firstPoint) throw new Error('Looped through all');
  if (firstPoint !== undefined) initialPoint = firstPoint;
  var data = Object(http_helpers_["generateJsonRPCObject"])('KeyAssign', {
    verifier: verifier,
    verifier_id: verifierId.toString()
  });
  return Object(http_helpers_["post"])('https://signer.tor.us/api/sign', data, {
    headers: {
      pubKeyX: torusNodePubs[nodeNum].X,
      pubKeyY: torusNodePubs[nodeNum].Y
    }
  }, {
    useAPIKey: true
  }).then(function (signedData) {
    return (// eslint-disable-next-line promise/no-nesting
      Object(http_helpers_["post"])(endpoints[nodeNum], _objectSpread(_objectSpread({}, data), signedData), {
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      })["catch"](function (_) {
        return keyAssign(endpoints, torusNodePubs, nodeNum + 1, initialPoint, verifier, verifierId);
      })
    );
  });
};
// CONCATENATED MODULE: ./src/torus.js







function torus_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function torus_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { torus_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { torus_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










 // Implement threshold logic wrappers around public APIs
// of Torus nodes to handle malicious node responses

var torus_Torus = /*#__PURE__*/function () {
  function Torus() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$enableLogging = _ref.enableLogging,
        enableLogging = _ref$enableLogging === void 0 ? false : _ref$enableLogging,
        _ref$metadataHost = _ref.metadataHost,
        metadataHost = _ref$metadataHost === void 0 ? 'https://metadata.tor.us' : _ref$metadataHost,
        _ref$allowHost = _ref.allowHost,
        allowHost = _ref$allowHost === void 0 ? 'https://signer.tor.us/api/allow' : _ref$allowHost;

    classCallCheck_default()(this, Torus);

    this.ec = new external_elliptic_["ec"]('secp256k1');
    this.metadataHost = metadataHost;
    this.allowHost = allowHost;
    this.metadataCache = external_memory_cache_default.a;
    loglevel.setDefaultLevel('DEBUG');
    if (!enableLogging) loglevel.disableAll();
    this.metadataLock = {};
  }

  createClass_default()(Torus, [{
    key: "retrieveShares",
    value: function () {
      var _retrieveShares = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(endpoints, indexes, verifier, verifierParams, idToken) {
        var _this = this;

        var promiseArr, tmpKey, pubKey, pubKeyX, pubKeyY, tokenCommitment, i, p;
        return regenerator_default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                promiseArr = [];
                _context2.next = 3;
                return Object(http_helpers_["get"])(this.allowHost, {}, {
                  useAPIKey: true
                });

              case 3:
                /* 
                  CommitmentRequestParams struct {
                    MessagePrefix      string `json:"messageprefix"`
                    TokenCommitment    string `json:"tokencommitment"`
                    TempPubX           string `json:"temppubx"`
                    TempPubY           string `json:"temppuby"`
                    VerifierIdentifier string `json:"verifieridentifier"`
                  } 
                  */
                // generate temporary private and public key that is used to secure receive shares
                tmpKey = Object(eccrypto_["generatePrivate"])();
                pubKey = Object(eccrypto_["getPublic"])(tmpKey).toString('hex');
                pubKeyX = pubKey.slice(2, 66);
                pubKeyY = pubKey.slice(66);
                tokenCommitment = Object(external_web3_utils_["keccak256"])(idToken); // make commitment requests to endpoints

                for (i = 0; i < endpoints.length; i += 1) {
                  p = Object(http_helpers_["post"])(endpoints[i], Object(http_helpers_["generateJsonRPCObject"])('CommitmentRequest', {
                    messageprefix: 'mug00',
                    tokencommitment: tokenCommitment.slice(2),
                    temppubx: pubKeyX,
                    temppuby: pubKeyY,
                    verifieridentifier: verifier
                  }))["catch"](function (err) {
                    return loglevel.debug('commitment', err);
                  });
                  promiseArr.push(p);
                }
                /*
                  ShareRequestParams struct {
                    Item []bijson.RawMessage `json:"item"`
                  }
                  ShareRequestItem struct {
                    IDToken            string          `json:"idtoken"`
                    NodeSignatures     []NodeSignature `json:"nodesignatures"`
                    VerifierIdentifier string          `json:"verifieridentifier"`
                  }
                  NodeSignature struct {
                    Signature   string
                    Data        string
                    NodePubKeyX string
                    NodePubKeyY string
                  }
                  CommitmentRequestResult struct {
                    Signature string `json:"signature"`
                    Data      string `json:"data"`
                    NodePubX  string `json:"nodepubx"`
                    NodePubY  string `json:"nodepuby"`
                  }
                  */
                // send share request once k + t number of commitment requests have completed


                return _context2.abrupt("return", Some(promiseArr, function (resultArr) {
                  var completedRequests = resultArr.filter(function (x) {
                    if (!x || typeof_default()(x) !== 'object') {
                      return false;
                    }

                    if (x.error) {
                      return false;
                    }

                    return true;
                  });

                  if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {
                    return Promise.resolve(resultArr);
                  }

                  return Promise.reject(new Error('invalid'));
                }).then(function (responses) {
                  var promiseArrRequest = [];
                  var nodeSigs = [];

                  for (var _i = 0; _i < responses.length; _i += 1) {
                    if (responses[_i]) nodeSigs.push(responses[_i].result);
                  }

                  for (var _i2 = 0; _i2 < endpoints.length; _i2 += 1) {
                    // eslint-disable-next-line promise/no-nesting
                    var _p = Object(http_helpers_["post"])(endpoints[_i2], Object(http_helpers_["generateJsonRPCObject"])('ShareRequest', {
                      encrypted: 'yes',
                      item: [torus_objectSpread(torus_objectSpread({}, verifierParams), {}, {
                        idtoken: idToken,
                        nodesignatures: nodeSigs,
                        verifieridentifier: verifier
                      })]
                    }))["catch"](function (err) {
                      return loglevel.debug('share req', err);
                    });

                    promiseArrRequest.push(_p);
                  }

                  return Some(promiseArrRequest, /*#__PURE__*/function () {
                    var _ref2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee(shareResponses, sharedState) {
                      var completedRequests, thresholdPublicKey, sharePromises, nodeIndex, _i3, metadata, sharesResolved, decryptedShares, allCombis, privateKey, _loop, j, _ret, metadataNonce, ethAddress;

                      return regenerator_default.a.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              /*
                                    ShareRequestResult struct {
                                      Keys []KeyAssignment
                                    }
                                            / KeyAssignmentPublic -
                                    type KeyAssignmentPublic struct {
                                      Index     big.Int
                                      PublicKey common.Point
                                      Threshold int
                                      Verifiers map[string][]string // Verifier => VerifierID
                                    }
                                     // KeyAssignment -
                                    type KeyAssignment struct {
                                      KeyAssignmentPublic
                                      Share big.Int // Or Si
                                    }
                                  */
                              // check if threshold number of nodes have returned the same user public key
                              completedRequests = shareResponses.filter(function (x) {
                                return x;
                              });
                              thresholdPublicKey = utils_thresholdSame(shareResponses.map(function (x) {
                                return x && x.result && x.result.keys[0].PublicKey;
                              }), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received
                              // this is matched against the user public key to ensure that shares are consistent

                              if (!(completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey)) {
                                _context.next = 32;
                                break;
                              }

                              sharePromises = [];
                              nodeIndex = [];

                              for (_i3 = 0; _i3 < shareResponses.length; _i3 += 1) {
                                if (shareResponses[_i3] && shareResponses[_i3].result && shareResponses[_i3].result.keys && shareResponses[_i3].result.keys.length > 0) {
                                  shareResponses[_i3].result.keys.sort(function (a, b) {
                                    return new external_bn_js_default.a(a.Index, 16).cmp(new external_bn_js_default.a(b.Index, 16));
                                  });

                                  if (shareResponses[_i3].result.keys[0].Metadata) {
                                    metadata = {
                                      ephemPublicKey: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.ephemPublicKey, 'hex'),
                                      iv: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.iv, 'hex'),
                                      mac: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mac, 'hex'),
                                      mode: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mode, 'hex')
                                    };
                                    sharePromises.push( // eslint-disable-next-line promise/no-nesting
                                    Object(eccrypto_["decrypt"])(tmpKey, torus_objectSpread(torus_objectSpread({}, metadata), {}, {
                                      ciphertext: Buffer.from(atob(shareResponses[_i3].result.keys[0].Share).padStart(64, '0'), 'hex')
                                    }))["catch"](function (err) {
                                      return loglevel.debug('share decryption', err);
                                    }));
                                  } else {
                                    sharePromises.push(Promise.resolve(Buffer.from(shareResponses[_i3].result.keys[0].Share.padStart(64, '0'), 'hex')));
                                  }
                                } else {
                                  sharePromises.push(Promise.resolve(undefined));
                                }

                                nodeIndex.push(new external_bn_js_default.a(indexes[_i3], 16));
                              }

                              _context.next = 8;
                              return Promise.all(sharePromises);

                            case 8:
                              sharesResolved = _context.sent;

                              if (!sharedState.resolved) {
                                _context.next = 11;
                                break;
                              }

                              return _context.abrupt("return", undefined);

                            case 11:
                              decryptedShares = sharesResolved.reduce(function (acc, curr, index) {
                                if (curr) acc.push({
                                  index: nodeIndex[index],
                                  value: new external_bn_js_default.a(curr)
                                });
                                return acc;
                              }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit

                              allCombis = utils_kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);

                              _loop = function _loop(j) {
                                var currentCombi = allCombis[j];
                                var currentCombiShares = decryptedShares.filter(function (v, index) {
                                  return currentCombi.includes(index);
                                });
                                var shares = currentCombiShares.map(function (x) {
                                  return x.value;
                                });
                                var indices = currentCombiShares.map(function (x) {
                                  return x.index;
                                });

                                var derivedPrivateKey = _this.lagrangeInterpolation(shares, indices);

                                var decryptedPubKey = Object(eccrypto_["getPublic"])(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex');
                                var decryptedPubKeyX = decryptedPubKey.slice(2, 66);
                                var decryptedPubKeyY = decryptedPubKey.slice(66);

                                if (new external_bn_js_default.a(decryptedPubKeyX, 16).cmp(new external_bn_js_default.a(thresholdPublicKey.X, 16)) === 0 && new external_bn_js_default.a(decryptedPubKeyY, 16).cmp(new external_bn_js_default.a(thresholdPublicKey.Y, 16)) === 0) {
                                  privateKey = derivedPrivateKey;
                                  return "break";
                                }
                              };

                              j = 0;

                            case 15:
                              if (!(j < allCombis.length)) {
                                _context.next = 22;
                                break;
                              }

                              _ret = _loop(j);

                              if (!(_ret === "break")) {
                                _context.next = 19;
                                break;
                              }

                              return _context.abrupt("break", 22);

                            case 19:
                              j += 1;
                              _context.next = 15;
                              break;

                            case 22:
                              if (!(privateKey === undefined)) {
                                _context.next = 24;
                                break;
                              }

                              throw new Error('could not derive private key');

                            case 24:
                              _context.next = 26;
                              return _this.getMetadata({
                                pub_key_X: thresholdPublicKey.X,
                                pub_key_Y: thresholdPublicKey.Y
                              });

                            case 26:
                              metadataNonce = _context.sent;

                              if (!sharedState.resolved) {
                                _context.next = 29;
                                break;
                              }

                              return _context.abrupt("return", undefined);

                            case 29:
                              privateKey = privateKey.add(metadataNonce).umod(_this.ec.curve.n);
                              ethAddress = _this.generateAddressFromPrivKey(privateKey); // return reconstructed private key and ethereum address

                              return _context.abrupt("return", {
                                ethAddress: ethAddress,
                                privKey: privateKey.toString('hex', 64)
                              });

                            case 32:
                              throw new Error('invalid');

                            case 33:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }));

                    return function (_x6, _x7) {
                      return _ref2.apply(this, arguments);
                    };
                  }());
                }));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function retrieveShares(_x, _x2, _x3, _x4, _x5) {
        return _retrieveShares.apply(this, arguments);
      }

      return retrieveShares;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3(data, options) {
        var _this2 = this;

        var unlock, dataKey, cachedResult, metadataResponse;
        return regenerator_default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                dataKey = JSON.stringify(data);

                if (!(this.metadataLock[dataKey] !== null)) {
                  _context3.next = 7;
                  break;
                }

                _context3.next = 5;
                return this.metadataLock[dataKey];

              case 5:
                _context3.next = 8;
                break;

              case 7:
                this.metadataLock[dataKey] = new Promise(function (resolve) {
                  unlock = function unlock() {
                    _this2.metadataLock[dataKey] = null;
                    resolve();
                  };
                });

              case 8:
                cachedResult = this.metadataCache.get(dataKey);

                if (!(cachedResult !== null)) {
                  _context3.next = 12;
                  break;
                }

                if (unlock) unlock();
                return _context3.abrupt("return", cachedResult);

              case 12:
                _context3.next = 14;
                return Object(http_helpers_["post"])("".concat(this.metadataHost, "/get"), data, options, {
                  useAPIKey: true
                });

              case 14:
                metadataResponse = _context3.sent;

                if (!(!metadataResponse || !metadataResponse.message)) {
                  _context3.next = 19;
                  break;
                }

                this.metadataCache.put(dataKey, new external_bn_js_default.a(0), 60000);
                if (unlock) unlock();
                return _context3.abrupt("return", new external_bn_js_default.a(0));

              case 19:
                this.metadataCache.put(dataKey, new external_bn_js_default.a(metadataResponse.message, 16), 60000);
                return _context3.abrupt("return", new external_bn_js_default.a(metadataResponse.message, 16));

              case 23:
                _context3.prev = 23;
                _context3.t0 = _context3["catch"](0);
                loglevel.error(_context3.t0);
                if (unlock) unlock();
                return _context3.abrupt("return", new external_bn_js_default.a(0));

              case 28:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 23]]);
      }));

      function getMetadata(_x8, _x9) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
  }, {
    key: "generateMetadataParams",
    value: function generateMetadataParams(message, privateKey) {
      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64));
      var setData = {
        data: message,
        timestamp: new external_bn_js_default.a(~~(Date.now() / 1000)).toString(16)
      };
      var sig = key.sign(Object(external_web3_utils_["keccak256"])(JSON.stringify(setData)).slice(2));
      return {
        pub_key_X: key.getPublic().getX().toString('hex'),
        pub_key_Y: key.getPublic().getY().toString('hex'),
        set_data: setData,
        signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new external_bn_js_default.a(sig.v).toString(16, 2), 'hex').toString('base64')
      };
    }
  }, {
    key: "setMetadata",
    value: function () {
      var _setMetadata = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee4(data, options) {
        var metadataResponse;
        return regenerator_default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return Object(http_helpers_["post"])("".concat(this.metadataHost, "/set"), data, options, {
                  useAPIKey: true
                });

              case 3:
                metadataResponse = _context4.sent;
                return _context4.abrupt("return", metadataResponse.message);

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](0);
                loglevel.error(_context4.t0);
                return _context4.abrupt("return", '');

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 7]]);
      }));

      function setMetadata(_x10, _x11) {
        return _setMetadata.apply(this, arguments);
      }

      return setMetadata;
    }()
  }, {
    key: "lagrangeInterpolation",
    value: function lagrangeInterpolation(shares, nodeIndex) {
      if (shares.length !== nodeIndex.length) {
        return null;
      }

      var secret = new external_bn_js_default.a(0);

      for (var i = 0; i < shares.length; i += 1) {
        var upper = new external_bn_js_default.a(1);
        var lower = new external_bn_js_default.a(1);

        for (var j = 0; j < shares.length; j += 1) {
          if (i !== j) {
            upper = upper.mul(nodeIndex[j].neg());
            upper = upper.umod(this.ec.curve.n);
            var temp = nodeIndex[i].sub(nodeIndex[j]);
            temp = temp.umod(this.ec.curve.n);
            lower = lower.mul(temp).umod(this.ec.curve.n);
          }
        }

        var delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);
        delta = delta.mul(shares[i]).umod(this.ec.curve.n);
        secret = secret.add(delta);
      }

      return secret.umod(this.ec.curve.n);
    }
  }, {
    key: "generateAddressFromPrivKey",
    value: function generateAddressFromPrivKey(privateKey) {
      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex');
      var publicKey = key.getPublic().encode('hex').slice(2);
      var ethAddressLower = "0x".concat(Object(external_web3_utils_["keccak256"])(Buffer.from(publicKey, 'hex')).slice(64 - 38));
      return Object(external_web3_utils_["toChecksumAddress"])(ethAddressLower);
    }
  }, {
    key: "generateAddressFromPubKey",
    value: function generateAddressFromPubKey(publicKeyX, publicKeyY) {
      var key = this.ec.keyFromPublic({
        x: publicKeyX.toString('hex', 64),
        y: publicKeyY.toString('hex', 64)
      });
      var publicKey = key.getPublic().encode('hex').slice(2);
      var ethAddressLower = "0x".concat(Object(external_web3_utils_["keccak256"])(Buffer.from(publicKey, 'hex')).slice(64 - 38));
      return Object(external_web3_utils_["toChecksumAddress"])(ethAddressLower);
    }
  }, {
    key: "getPublicAddress",
    value: function getPublicAddress(endpoints, torusNodePubs, _ref3) {
      var _this3 = this;

      var verifier = _ref3.verifier,
          verifierId = _ref3.verifierId;
      var isExtended = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      return utils_keyLookup(endpoints, verifier, verifierId).then(function () {
        var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            keyResult = _ref4.keyResult,
            errorResult = _ref4.errorResult;

        if (errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned')) {
          // eslint-disable-next-line promise/no-nesting
          return utils_keyAssign(endpoints, torusNodePubs, undefined, undefined, verifier, verifierId).then(function (_) {
            return utils_keyLookup(endpoints, verifier, verifierId);
          });
        }

        if (keyResult) {
          return {
            keyResult: keyResult
          };
        }

        throw new Error('node results do not match');
      }).then( /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee5() {
        var _ref6,
            keyResult,
            _keyResult$keys$,
            X,
            Y,
            nonce,
            modifiedPubKey,
            address,
            _args5 = arguments;

        return regenerator_default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _ref6 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, keyResult = _ref6.keyResult;

                if (!keyResult) {
                  _context5.next = 13;
                  break;
                }

                _keyResult$keys$ = keyResult.keys[0], X = _keyResult$keys$.pub_key_X, Y = _keyResult$keys$.pub_key_Y;
                _context5.next = 5;
                return _this3.getMetadata({
                  pub_key_X: X,
                  pub_key_Y: Y
                });

              case 5:
                nonce = _context5.sent;
                modifiedPubKey = _this3.ec.keyFromPublic({
                  x: X.toString(16),
                  y: Y.toString(16)
                }).getPublic().add(_this3.ec.keyFromPrivate(nonce.toString(16)).getPublic());
                X = modifiedPubKey.getX().toString(16);
                Y = modifiedPubKey.getY().toString(16);
                address = _this3.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());

                if (isExtended) {
                  _context5.next = 12;
                  break;
                }

                return _context5.abrupt("return", address);

              case 12:
                return _context5.abrupt("return", {
                  address: address,
                  X: X,
                  Y: Y
                });

              case 13:
                throw new Error('node results do not match');

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      })));
    }
  }], [{
    key: "setAPIKey",
    value: function setAPIKey(apiKey) {
      Object(http_helpers_["setAPIKey"])(apiKey);
    }
  }, {
    key: "setEmbedHost",
    value: function setEmbedHost(embedHost) {
      Object(http_helpers_["setEmbedHost"])(embedHost);
    }
  }]);

  return Torus;
}();

/* harmony default export */ var torus = (torus_Torus);
// CONCATENATED MODULE: ./index.js

/* harmony default export */ var index_0 = __webpack_exports__["default"] = (torus);

/***/ })
/******/ ])["default"];