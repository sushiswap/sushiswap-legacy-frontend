{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\"use strict\";\n\nvar _ = require('underscore');\n\nvar errors = require('web3-core-helpers').errors;\n\nvar EventEmitter = require('eventemitter3');\n\nvar formatters = require('web3-core-helpers').formatters;\n\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = _.identity;\n  this.arguments = null;\n  this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n} // INHERIT\n\n\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nSubscription.prototype._validateArgs = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) subscription = {};\n  if (!subscription.params) subscription.params = 0;\n\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nSubscription.prototype._formatInput = function (args) {\n  var subscription = this.options.subscription;\n\n  if (!subscription) {\n    return args;\n  }\n\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n\n  var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\n\n\nSubscription.prototype._formatOutput = function (result) {\n  var subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nSubscription.prototype._toPayload = function (args) {\n  var params = [];\n  this.callback = this._extractCallback(args) || _.identity;\n\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift(); // replace subscription with given name\n\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n\n    this._validateArgs(this.arguments);\n\n    args = []; // make empty after validation\n  } // re-add subscriptionName\n\n\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n\n  return {\n    method: this.options.type + '_subscribe',\n    params: params\n  };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\n\n\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.lastBlock = null;\n  this.removeAllListeners();\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\n\n\nSubscription.prototype.subscribe = function () {\n  var _this = this;\n\n  var args = Array.prototype.slice.call(arguments);\n\n  var payload = this._toPayload(args);\n\n  if (!payload) {\n    return this;\n  } // throw error, if provider is not set\n\n\n  if (!this.options.requestManager.provider) {\n    setTimeout(function () {\n      var err1 = new Error('No provider set.');\n\n      _this.callback(err1, null, _this);\n\n      _this.emit('error', err1);\n    }, 0);\n    return this;\n  } // throw error, if provider doesnt support subscriptions\n\n\n  if (!this.options.requestManager.provider.on) {\n    setTimeout(function () {\n      var err2 = new Error('The current provider doesn\\'t support subscriptions: ' + _this.options.requestManager.provider.constructor.name);\n\n      _this.callback(err2, null, _this);\n\n      _this.emit('error', err2);\n    }, 0);\n    return this;\n  } // Re-subscription only: continue fetching from the last block we received.\n  // a dropped connection may have resulted in gaps in the logs...\n\n\n  if (this.lastBlock && _.isObject(this.options.params)) {\n    payload.params[1] = this.options.params;\n    payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n  } // if id is there unsubscribe first\n\n\n  if (this.id) {\n    this.unsubscribe();\n  } // store the params in the options object\n\n\n  this.options.params = payload.params[1]; // get past logs, if fromBlock is available\n\n  if (payload.params[0] === 'logs' && _.isObject(payload.params[1]) && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n    // copy the params to avoid race-condition with deletion below this block\n    var blockParams = Object.assign({}, payload.params[1]);\n    this.options.requestManager.send({\n      method: 'eth_getLogs',\n      params: [blockParams]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          var output = _this._formatOutput(log);\n\n          _this.callback(null, output, _this);\n\n          _this.emit('data', output);\n        }); // TODO subscribe here? after the past logs?\n      } else {\n        setTimeout(function () {\n          _this.callback(err, null, _this);\n\n          _this.emit('error', err);\n        }, 0);\n      }\n    });\n  } // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n\n  if (typeof payload.params[1] === 'object') delete payload.params[1].fromBlock;\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n      _this.method = payload.params[0];\n\n      _this.emit('connected', result); // call callback on notifications\n\n\n      _this.options.requestManager.addSubscription(_this, function (error, result) {\n        if (!error) {\n          if (!_.isArray(result)) {\n            result = [result];\n          }\n\n          result.forEach(function (resultItem) {\n            var output = _this._formatOutput(resultItem); // Track current block (for gaps introduced by dropped connections)\n\n\n            _this.lastBlock = _.isObject(output) ? output.blockNumber : null;\n\n            if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            } else {\n              _this.emit('data', output);\n            } // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n            _this.callback(null, output, _this);\n          });\n        } else {\n          _this.callback(error, false, _this);\n\n          _this.emit('error', error);\n        }\n      });\n    } else {\n      setTimeout(function () {\n        _this.callback(err, false, _this);\n\n        _this.emit('error', err);\n      }, 0);\n    }\n  }); // return an object to cancel the subscription\n\n  return this;\n};\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\n\n\nSubscription.prototype.resubscribe = function () {\n  this.options.requestManager.removeSubscription(this.id); // unsubscribe\n\n  this.id = null;\n  this.subscribe(this.callback);\n};\n\nmodule.exports = Subscription;","map":{"version":3,"sources":["/Users/matt/Projects/sushiswap-frontend/node_modules/web3-core-subscriptions/src/subscription.js"],"names":["_","require","errors","EventEmitter","formatters","Subscription","options","call","id","callback","identity","arguments","lastBlock","subscription","type","requestManager","prototype","Object","create","constructor","_extractCallback","args","isFunction","length","pop","_validateArgs","params","InvalidNumberOfParams","subscriptionName","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","subscribe","_this","Array","slice","payload","provider","setTimeout","err1","emit","on","err2","name","isObject","fromBlock","inputBlockNumberFormatter","hasOwnProperty","isFinite","blockParams","assign","send","err","logs","forEach","log","output","addSubscription","error","isArray","resultItem","blockNumber","subscriptionHandler","resubscribe","module","exports"],"mappings":"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","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\nvar formatters = require('web3-core-helpers').formatters;\n\nfunction Subscription(options) {\n    EventEmitter.call(this);\n\n    this.id = null;\n    this.callback = _.identity;\n    this.arguments = null;\n    this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager\n    };\n}\n\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\nSubscription.prototype._validateArgs = function (args) {\n    var subscription = this.options.subscription;\n\n    if(!subscription)\n        subscription = {};\n\n    if(!subscription.params)\n        subscription.params = 0;\n\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(\n            args.length,\n            subscription.params,\n            subscription.subscriptionName\n        );\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\nSubscription.prototype._formatInput = function (args) {\n    var subscription = this.options.subscription;\n\n    if (!subscription) {\n        return args;\n    }\n\n    if (!subscription.inputFormatter) {\n        return args;\n    }\n\n    var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n        return formatter ? formatter(args[index]) : args[index];\n    });\n\n    return formattedArgs;\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\n\nSubscription.prototype._formatOutput = function (result) {\n    var subscription = this.options.subscription;\n\n    return (subscription && subscription.outputFormatter && result) ? subscription.outputFormatter(result) : result;\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n    var params = [];\n    this.callback = this._extractCallback(args) || _.identity;\n\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift();\n\n        // replace subscription with given name\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName;\n        }\n    }\n\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args);\n        this._validateArgs(this.arguments);\n        args = []; // make empty after validation\n\n    }\n\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod);\n    params = params.concat(this.arguments);\n\n\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n    }\n\n    return {\n        method: this.options.type + '_subscribe',\n        params: params\n    };\n};\n\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function(callback) {\n    this.options.requestManager.removeSubscription(this.id, callback);\n    this.id = null;\n    this.lastBlock = null;\n    this.removeAllListeners();\n};\n\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function() {\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments);\n    var payload = this._toPayload(args);\n\n    if(!payload) {\n        return this;\n    }\n\n    // throw error, if provider is not set\n    if(!this.options.requestManager.provider) {\n        setTimeout(function(){\n            var err1 = new Error('No provider set.');\n            _this.callback(err1, null, _this);\n            _this.emit('error', err1);\n        },0);\n\n        return this;\n    }\n\n    // throw error, if provider doesnt support subscriptions\n    if(!this.options.requestManager.provider.on) {\n        setTimeout(function(){\n            var err2 = new Error(\n                'The current provider doesn\\'t support subscriptions: ' +\n                _this.options.requestManager.provider.constructor.name\n            );\n            _this.callback(err2, null, _this);\n            _this.emit('error', err2);\n        },0);\n\n        return this;\n    }\n\n    // Re-subscription only: continue fetching from the last block we received.\n    // a dropped connection may have resulted in gaps in the logs...\n    if (this.lastBlock && _.isObject(this.options.params)){\n        payload.params[1] = this.options.params\n        payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n    }\n\n    // if id is there unsubscribe first\n    if (this.id) {\n        this.unsubscribe();\n    }\n\n    // store the params in the options object\n    this.options.params = payload.params[1];\n\n    // get past logs, if fromBlock is available\n    if(payload.params[0] === 'logs' && _.isObject(payload.params[1]) && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n        // send the subscription request\n\n        // copy the params to avoid race-condition with deletion below this block\n        var blockParams = Object.assign({}, payload.params[1]);\n\n        this.options.requestManager.send({\n            method: 'eth_getLogs',\n            params: [blockParams]\n        }, function (err, logs) {\n            if(!err) {\n                logs.forEach(function(log){\n                    var output = _this._formatOutput(log);\n                    _this.callback(null, output, _this);\n                    _this.emit('data', output);\n                });\n\n                // TODO subscribe here? after the past logs?\n\n            } else {\n                setTimeout(function(){\n                    _this.callback(err, null, _this);\n                    _this.emit('error', err);\n                },0);\n            }\n        });\n    }\n\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n\n    if(typeof payload.params[1] === 'object')\n        delete payload.params[1].fromBlock;\n\n    this.options.requestManager.send(payload, function (err, result) {\n        if(!err && result) {\n            _this.id = result;\n            _this.method = payload.params[0];\n            _this.emit('connected', result);\n\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this, function(error, result) {\n                if (!error) {\n                    if (!_.isArray(result)) {\n                        result = [result];\n                    }\n\n                    result.forEach(function(resultItem) {\n                        var output = _this._formatOutput(resultItem);\n\n                        // Track current block (for gaps introduced by dropped connections)\n                        _this.lastBlock = _.isObject(output) ? output.blockNumber : null;\n\n                        if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output);\n                        } else {\n                            _this.emit('data', output);\n                        }\n\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        _this.callback(null, output, _this);\n                    });\n                } else {\n                    _this.callback(error, false, _this);\n                    _this.emit('error', error);\n                }\n            });\n        } else {\n            setTimeout(function(){\n                _this.callback(err, false, _this);\n                _this.emit('error', err);\n            },0);\n        }\n    });\n\n    // return an object to cancel the subscription\n    return this;\n};\n\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\nSubscription.prototype.resubscribe = function () {\n    this.options.requestManager.removeSubscription(this.id); // unsubscribe\n    this.id = null;\n\n    this.subscribe(this.callback);\n};\n\nmodule.exports = Subscription;\n"]},"metadata":{},"sourceType":"script"}