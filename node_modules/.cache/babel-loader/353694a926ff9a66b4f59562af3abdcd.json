{"ast":null,"code":"'use strict'; // This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\n\nvar BN = require('bn.js');\n\nvar EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve;\n\nexports.privateKeyExport = function (privateKey, compressed) {\n  var d = new BN(privateKey);\n\n  if (d.ucmp(ecparams.n) >= 0) {\n    throw new Error('couldn\\'t export to DER format');\n  }\n\n  var point = ec.g.mul(d);\n  return toPublicKey(point.getX(), point.getY(), compressed);\n};\n\nexports.privateKeyModInverse = function (privateKey) {\n  var bn = new BN(privateKey);\n\n  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n    throw new Error('private key range is invalid');\n  }\n\n  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\n};\n\nexports.signatureImport = function (sigObj) {\n  var r = new BN(sigObj.r);\n\n  if (r.ucmp(ecparams.n) >= 0) {\n    r = new BN(0);\n  }\n\n  var s = new BN(sigObj.s);\n\n  if (s.ucmp(ecparams.n) >= 0) {\n    s = new BN(0);\n  }\n\n  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\n};\n\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  var point = ec.keyFromPublic(publicKey);\n  var scalar = new BN(privateKey);\n\n  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n    throw new Error('scalar was invalid (zero or overflow)');\n  }\n\n  var shared = point.pub.mul(scalar);\n  return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\n\nvar toPublicKey = function toPublicKey(x, y, compressed) {\n  var publicKey = void 0;\n\n  if (compressed) {\n    publicKey = Buffer.alloc(33);\n    publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n  } else {\n    publicKey = Buffer.alloc(65);\n    publicKey[0] = 0x04;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\n  }\n\n  return publicKey;\n};","map":{"version":3,"sources":["/Users/matt/Projects/sushiswap-frontend/node_modules/ethereumjs-util/dist/secp256k1-lib/index.js"],"names":["BN","require","EC","ec","ecparams","curve","exports","privateKeyExport","privateKey","compressed","d","ucmp","n","Error","point","g","mul","toPublicKey","getX","getY","privateKeyModInverse","bn","isZero","invm","toArrayLike","Buffer","signatureImport","sigObj","r","s","concat","ecdhUnsafe","publicKey","keyFromPublic","scalar","shared","pub","x","y","alloc","isOdd","copy"],"mappings":"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","sourcesContent":["'use strict';\n\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\n\nvar BN = require('bn.js');\nvar EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve;\n\nexports.privateKeyExport = function (privateKey, compressed) {\n  var d = new BN(privateKey);\n  if (d.ucmp(ecparams.n) >= 0) {\n    throw new Error('couldn\\'t export to DER format');\n  }\n\n  var point = ec.g.mul(d);\n  return toPublicKey(point.getX(), point.getY(), compressed);\n};\n\nexports.privateKeyModInverse = function (privateKey) {\n  var bn = new BN(privateKey);\n  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n    throw new Error('private key range is invalid');\n  }\n\n  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\n};\n\nexports.signatureImport = function (sigObj) {\n  var r = new BN(sigObj.r);\n  if (r.ucmp(ecparams.n) >= 0) {\n    r = new BN(0);\n  }\n\n  var s = new BN(sigObj.s);\n  if (s.ucmp(ecparams.n) >= 0) {\n    s = new BN(0);\n  }\n\n  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\n};\n\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  var point = ec.keyFromPublic(publicKey);\n\n  var scalar = new BN(privateKey);\n  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n    throw new Error('scalar was invalid (zero or overflow)');\n  }\n\n  var shared = point.pub.mul(scalar);\n  return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\n\nvar toPublicKey = function toPublicKey(x, y, compressed) {\n  var publicKey = void 0;\n\n  if (compressed) {\n    publicKey = Buffer.alloc(33);\n    publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n  } else {\n    publicKey = Buffer.alloc(65);\n    publicKey[0] = 0x04;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\n  }\n\n  return publicKey;\n};"]},"metadata":{},"sourceType":"script"}