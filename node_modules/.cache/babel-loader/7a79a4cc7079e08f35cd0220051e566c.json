{"ast":null,"code":"const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n};\n\nfunction assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction isUint8Array(name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ');\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;\n      assert(length.includes(value.length), msg);\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`;\n      assert(value.length === length, msg);\n    }\n  }\n}\n\nfunction isCompressed(value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');\n}\n\nfunction getAssertedOutput(output = len => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length);\n  isUint8Array('output', output, length);\n  return output;\n}\n\nfunction toTypeString(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nmodule.exports = secp256k1 => {\n  return {\n    contextRandomize(seed) {\n      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');\n      if (seed !== null) isUint8Array('seed', seed, 32);\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n      }\n    },\n\n    privateKeyVerify(seckey) {\n      isUint8Array('private key', seckey, 32);\n      return secp256k1.privateKeyVerify(seckey) === 0;\n    },\n\n    privateKeyNegate(seckey) {\n      isUint8Array('private key', seckey, 32);\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    privateKeyTweakAdd(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n\n    privateKeyTweakMul(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n\n    publicKeyVerify(pubkey) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      return secp256k1.publicKeyVerify(pubkey) === 0;\n    },\n\n    publicKeyCreate(seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SECKEY_INVALID);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyConvert(pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyNegate(pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyCombine(pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');\n\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65]);\n      }\n\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n\n    publicKeyTweakMul(pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n\n    signatureNormalize(sig) {\n      isUint8Array('signature', sig, 64);\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n      }\n    },\n\n    signatureExport(sig, output) {\n      isUint8Array('signature', sig, 64);\n      output = getAssertedOutput(output, 72);\n      const obj = {\n        output,\n        outputlen: 72\n      };\n\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen);\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    signatureImport(sig, output) {\n      isUint8Array('signature', sig);\n      output = getAssertedOutput(output, 64);\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    ecdsaSign(msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');\n      output = getAssertedOutput(output, 64);\n      const obj = {\n        signature: output,\n        recid: null\n      };\n\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj;\n\n        case 1:\n          throw new Error(errors.SIGN);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    ecdsaVerify(sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64);\n      isUint8Array('message', msg32, 32);\n      isUint8Array('public key', pubkey, [33, 65]);\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true;\n\n        case 3:\n          return false;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE);\n      }\n    },\n\n    ecdsaRecover(sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64);\n      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');\n      isUint8Array('message', msg32, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.RECOVER);\n\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    ecdh(pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);\n        isUint8Array('output', output);\n      } else {\n        output = getAssertedOutput(output, 32);\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.ECDH);\n      }\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/matt/Projects/sushiswap-frontend/node_modules/ethereum-cryptography/node_modules/secp256k1/lib/index.js"],"names":["errors","IMPOSSIBLE_CASE","TWEAK_ADD","TWEAK_MUL","CONTEXT_RANDOMIZE_UNKNOW","SECKEY_INVALID","PUBKEY_PARSE","PUBKEY_SERIALIZE","PUBKEY_COMBINE","SIG_PARSE","SIGN","RECOVER","ECDH","assert","cond","msg","Error","isUint8Array","name","value","length","Uint8Array","undefined","Array","isArray","numbers","join","includes","isCompressed","toTypeString","getAssertedOutput","output","len","Object","prototype","toString","call","slice","module","exports","secp256k1","contextRandomize","seed","privateKeyVerify","seckey","privateKeyNegate","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyVerify","pubkey","publicKeyCreate","compressed","publicKeyConvert","publicKeyNegate","publicKeyCombine","pubkeys","publicKeyTweakAdd","publicKeyTweakMul","signatureNormalize","sig","signatureExport","obj","outputlen","signatureImport","ecdsaSign","msg32","options","data","noncefn","signature","recid","ecdsaVerify","ecdsaRecover","ecdh","hashfn","xbuf","ybuf"],"mappings":"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","sourcesContent":["const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}