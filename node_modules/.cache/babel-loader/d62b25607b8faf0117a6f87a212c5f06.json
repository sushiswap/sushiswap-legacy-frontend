{"ast":null,"code":"// TODO: this is a temporary fix to hide those libraries from the browser. A\n// slightly better long-term solution would be to split this file into two,\n// separating the functions that are used on Node.js from the functions that\n// are used only on the browser.\nmodule.exports = function (_ref) {\n  var fs = _ref.fs,\n      files = _ref.files,\n      os = _ref.os,\n      path = _ref.path,\n      child_process = _ref.child_process,\n      mimetype = _ref.mimetype,\n      defaultArchives = _ref.defaultArchives,\n      request = _ref.request,\n      downloadUrl = _ref.downloadUrl,\n      bytes = _ref.bytes,\n      hash = _ref.hash,\n      pick = _ref.pick; // ∀ a . String -> JSON -> Map String a -o Map String a\n  //   Inserts a key/val pair in an object impurely.\n\n  var impureInsert = function impureInsert(key) {\n    return function (val) {\n      return function (map) {\n        return map[key] = val, map;\n      };\n    };\n  }; // String -> JSON -> Map String JSON\n  //   Merges an array of keys and an array of vals into an object.\n\n\n  var toMap = function toMap(keys) {\n    return function (vals) {\n      var map = {};\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        map[keys[i]] = vals[i];\n      }\n\n      return map;\n    };\n  }; // ∀ a . Map String a -> Map String a -> Map String a\n  //   Merges two maps into one.\n\n\n  var merge = function merge(a) {\n    return function (b) {\n      var map = {};\n\n      for (var key in a) {\n        map[key] = a[key];\n      }\n\n      for (var _key in b) {\n        map[_key] = b[_key];\n      }\n\n      return map;\n    };\n  }; // ∀ a . [a] -> [a] -> Bool\n\n\n  var equals = function equals(a) {\n    return function (b) {\n      if (a.length !== b.length) {\n        return false;\n      } else {\n        for (var i = 0, l = a.length; i < l; ++i) {\n          if (a[i] !== b[i]) return false;\n        }\n      }\n\n      return true;\n    };\n  }; // String -> String -> String\n\n\n  var rawUrl = function rawUrl(swarmUrl) {\n    return function (hash) {\n      return \"\".concat(swarmUrl, \"/bzz-raw:/\").concat(hash);\n    };\n  }; // String -> String -> Promise Uint8Array\n  //   Gets the raw contents of a Swarm hash address.\n\n\n  var downloadData = function downloadData(swarmUrl) {\n    return function (hash) {\n      return new Promise(function (resolve, reject) {\n        request(rawUrl(swarmUrl)(hash), {\n          responseType: \"arraybuffer\"\n        }, function (err, arrayBuffer, response) {\n          if (err) {\n            return reject(err);\n          }\n\n          if (response.statusCode >= 400) {\n            return reject(new Error(\"Error \".concat(response.statusCode, \".\")));\n          }\n\n          return resolve(new Uint8Array(arrayBuffer));\n        });\n      });\n    };\n  }; // type Entry = {\"type\": String, \"hash\": String}\n  // type File = {\"type\": String, \"data\": Uint8Array}\n  // String -> String -> Promise (Map String Entry)\n  //   Solves the manifest of a Swarm address recursively.\n  //   Returns a map from full paths to entries.\n\n\n  var downloadEntries = function downloadEntries(swarmUrl) {\n    return function (hash) {\n      var search = function search(hash) {\n        return function (path) {\n          return function (routes) {\n            // Formats an entry to the Swarm.js type.\n            var format = function format(entry) {\n              return {\n                type: entry.contentType,\n                hash: entry.hash\n              };\n            }; // To download a single entry:\n            //   if type is bzz-manifest, go deeper\n            //   if not, add it to the routing table\n\n\n            var downloadEntry = function downloadEntry(entry) {\n              if (entry.path === undefined) {\n                return Promise.resolve();\n              } else {\n                return entry.contentType === \"application/bzz-manifest+json\" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));\n              }\n            }; // Downloads the initial manifest and then each entry.\n\n\n            return downloadData(swarmUrl)(hash).then(function (text) {\n              return JSON.parse(toString(text)).entries;\n            }).then(function (entries) {\n              return Promise.all(entries.map(downloadEntry));\n            }).then(function () {\n              return routes;\n            });\n          };\n        };\n      };\n\n      return search(hash)(\"\")({});\n    };\n  }; // String -> String -> Promise (Map String String)\n  //   Same as `downloadEntries`, but returns only hashes (no types).\n\n\n  var downloadRoutes = function downloadRoutes(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {\n          return entries[route].hash;\n        }));\n      });\n    };\n  }; // String -> String -> Promise (Map String File)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectory = function downloadDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        var paths = Object.keys(entries);\n        var hashs = paths.map(function (path) {\n          return entries[path].hash;\n        });\n        var types = paths.map(function (path) {\n          return entries[path].type;\n        });\n        var datas = hashs.map(downloadData(swarmUrl));\n\n        var files = function files(datas) {\n          return datas.map(function (data, i) {\n            return {\n              type: types[i],\n              data: data\n            };\n          });\n        };\n\n        return Promise.all(datas).then(function (datas) {\n          return toMap(paths)(files(datas));\n        });\n      });\n    };\n  }; // String -> String -> String -> Promise String\n  //   Gets the raw contents of a Swarm hash address.\n  //   Returns a promise with the downloaded file path.\n\n\n  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {\n    return function (hash) {\n      return function (filePath) {\n        return files.download(rawUrl(swarmUrl)(hash))(filePath);\n      };\n    };\n  }; // String -> String -> String -> Promise (Map String String)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {\n    return function (hash) {\n      return function (dirPath) {\n        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {\n          var downloads = [];\n\n          for (var route in routingTable) {\n            if (route.length > 0) {\n              var filePath = path.join(dirPath, route);\n              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));\n            }\n\n            ;\n          }\n\n          ;\n          return Promise.all(downloads).then(function () {\n            return dirPath;\n          });\n        });\n      };\n    };\n  }; // String -> Uint8Array -> Promise String\n  //   Uploads raw data to Swarm.\n  //   Returns a promise with the uploaded hash.\n\n\n  var uploadData = function uploadData(swarmUrl) {\n    return function (data) {\n      return new Promise(function (resolve, reject) {\n        var params = {\n          body: typeof data === \"string\" ? fromString(data) : data,\n          method: \"POST\"\n        };\n        request(\"\".concat(swarmUrl, \"/bzz-raw:/\"), params, function (err, data) {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(data);\n        });\n      });\n    };\n  }; // String -> String -> String -> File -> Promise String\n  //   Uploads a file to the Swarm manifest at a given hash, under a specific\n  //   route. Returns a promise containing the uploaded hash.\n  //   FIXME: for some reasons Swarm-Gateways is sometimes returning\n  //   error 404 (bad request), so we retry up to 3 times. Why?\n\n\n  var uploadToManifest = function uploadToManifest(swarmUrl) {\n    return function (hash) {\n      return function (route) {\n        return function (file) {\n          var attempt = function attempt(n) {\n            var slashRoute = route[0] === \"/\" ? route : \"/\" + route;\n            var url = \"\".concat(swarmUrl, \"/bzz:/\").concat(hash).concat(slashRoute);\n            var opt = {\n              method: \"PUT\",\n              headers: {\n                \"Content-Type\": file.type\n              },\n              body: file.data\n            };\n            return new Promise(function (resolve, reject) {\n              request(url, opt, function (err, data) {\n                if (err) {\n                  return reject(err);\n                }\n\n                if (data.indexOf(\"error\") !== -1) {\n                  return reject(data);\n                }\n\n                return resolve(data);\n              });\n            })[\"catch\"](function (e) {\n              return n > 0 && attempt(n - 1);\n            });\n          };\n\n          return attempt(3);\n        };\n      };\n    };\n  }; // String -> {type: String, data: Uint8Array} -> Promise String\n\n\n  var uploadFile = function uploadFile(swarmUrl) {\n    return function (file) {\n      return uploadDirectory(swarmUrl)({\n        \"\": file\n      });\n    };\n  }; // String -> String -> Promise String\n\n\n  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(function (data) {\n        return uploadFile(swarmUrl)({\n          type: mimetype.lookup(filePath),\n          data: data\n        });\n      });\n    };\n  }; // String -> Map String File -> Promise String\n  //   Uploads a directory to Swarm. The directory is\n  //   represented as a map of routes and files.\n  //   A default path is encoded by having a \"\" route.\n\n\n  var uploadDirectory = function uploadDirectory(swarmUrl) {\n    return function (directory) {\n      return uploadData(swarmUrl)(\"{}\").then(function (hash) {\n        var uploadRoute = function uploadRoute(route) {\n          return function (hash) {\n            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);\n          };\n        };\n\n        var uploadToHash = function uploadToHash(hash, route) {\n          return hash.then(uploadRoute(route));\n        };\n\n        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));\n      });\n    };\n  }; // String -> Promise String\n\n\n  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(uploadData(swarmUrl));\n    };\n  }; // String -> Nullable String -> String -> Promise String\n\n\n  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {\n    return function (defaultPath) {\n      return function (dirPath) {\n        return files.directoryTree(dirPath).then(function (fullPaths) {\n          return Promise.all(fullPaths.map(function (path) {\n            return fs.readFile(path);\n          })).then(function (datas) {\n            var paths = fullPaths.map(function (path) {\n              return path.slice(dirPath.length);\n            });\n            var types = fullPaths.map(function (path) {\n              return mimetype.lookup(path) || \"text/plain\";\n            });\n            return toMap(paths)(datas.map(function (data, i) {\n              return {\n                type: types[i],\n                data: data\n              };\n            }));\n          });\n        }).then(function (directory) {\n          return merge(defaultPath ? {\n            \"\": directory[defaultPath]\n          } : {})(directory);\n        }).then(uploadDirectory(swarmUrl));\n      };\n    };\n  }; // String -> UploadInfo -> Promise String\n  //   Simplified multi-type upload which calls the correct\n  //   one based on the type of the argument given.\n\n\n  var _upload = function upload(swarmUrl) {\n    return function (arg) {\n      // Upload raw data from browser\n      if (arg.pick === \"data\") {\n        return pick.data().then(uploadData(swarmUrl)); // Upload a file from browser\n      } else if (arg.pick === \"file\") {\n        return pick.file().then(uploadFile(swarmUrl)); // Upload a directory from browser\n      } else if (arg.pick === \"directory\") {\n        return pick.directory().then(uploadDirectory(swarmUrl)); // Upload directory/file from disk\n      } else if (arg.path) {\n        switch (arg.kind) {\n          case \"data\":\n            return uploadDataFromDisk(swarmUrl)(arg.path);\n\n          case \"file\":\n            return uploadFileFromDisk(swarmUrl)(arg.path);\n\n          case \"directory\":\n            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);\n        }\n\n        ; // Upload UTF-8 string or raw data (buffer)\n      } else if (arg.length || typeof arg === \"string\") {\n        return uploadData(swarmUrl)(arg); // Upload directory with JSON\n      } else if (arg instanceof Object) {\n        return uploadDirectory(swarmUrl)(arg);\n      }\n\n      return Promise.reject(new Error(\"Bad arguments\"));\n    };\n  }; // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)\n  //   Simplified multi-type download which calls the correct function based on\n  //   the type of the argument given, and on whether the Swwarm address has a\n  //   directory or a file.\n\n\n  var _download = function download(swarmUrl) {\n    return function (hash) {\n      return function (path) {\n        return isDirectory(swarmUrl)(hash).then(function (isDir) {\n          if (isDir) {\n            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);\n          } else {\n            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);\n          }\n        });\n      };\n    };\n  }; // String -> Promise String\n  //   Downloads the Swarm binaries into a path. Returns a promise that only\n  //   resolves when the exact Swarm file is there, and verified to be correct.\n  //   If it was already there to begin with, skips the download.\n\n\n  var downloadBinary = function downloadBinary(path, archives) {\n    var system = os.platform().replace(\"win32\", \"windows\") + \"-\" + (os.arch() === \"x64\" ? \"amd64\" : \"386\");\n    var archive = (archives || defaultArchives)[system];\n    var archiveUrl = downloadUrl + archive.archive + \".tar.gz\";\n    var archiveMD5 = archive.archiveMD5;\n    var binaryMD5 = archive.binaryMD5;\n    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);\n  }; // type SwarmSetup = {\n  //   account : String,\n  //   password : String,\n  //   dataDir : String,\n  //   binPath : String,\n  //   ensApi : String,\n  //   onDownloadProgress : Number ~> (),\n  //   archives : [{\n  //     archive: String,\n  //     binaryMD5: String,\n  //     archiveMD5: String\n  //   }]\n  // }\n  // SwarmSetup ~> Promise Process\n  //   Starts the Swarm process.\n\n\n  var startProcess = function startProcess(swarmSetup) {\n    return new Promise(function (resolve, reject) {\n      var spawn = child_process.spawn;\n\n      var hasString = function hasString(str) {\n        return function (buffer) {\n          return ('' + buffer).indexOf(str) !== -1;\n        };\n      };\n\n      var account = swarmSetup.account,\n          password = swarmSetup.password,\n          dataDir = swarmSetup.dataDir,\n          ensApi = swarmSetup.ensApi,\n          privateKey = swarmSetup.privateKey;\n      var STARTUP_TIMEOUT_SECS = 3;\n      var WAITING_PASSWORD = 0;\n      var STARTING = 1;\n      var LISTENING = 2;\n      var PASSWORD_PROMPT_HOOK = \"Passphrase\";\n      var LISTENING_HOOK = \"Swarm http proxy started\";\n      var state = WAITING_PASSWORD;\n      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);\n\n      var handleProcessOutput = function handleProcessOutput(data) {\n        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {\n          setTimeout(function () {\n            state = STARTING;\n            swarmProcess.stdin.write(password + '\\n');\n          }, 500);\n        } else if (hasString(LISTENING_HOOK)(data)) {\n          state = LISTENING;\n          clearTimeout(timeout);\n          resolve(swarmProcess);\n        }\n      };\n\n      swarmProcess.stdout.on('data', handleProcessOutput);\n      swarmProcess.stderr.on('data', handleProcessOutput); //swarmProcess.on('close', () => setTimeout(restart, 2000));\n\n      var restart = function restart() {\n        return startProcess(swarmSetup).then(resolve)[\"catch\"](reject);\n      };\n\n      var error = function error() {\n        return reject(new Error(\"Couldn't start swarm process.\"));\n      };\n\n      var timeout = setTimeout(error, 20000);\n    });\n  }; // Process ~> Promise ()\n  //   Stops the Swarm process.\n\n\n  var stopProcess = function stopProcess(process) {\n    return new Promise(function (resolve, reject) {\n      process.stderr.removeAllListeners('data');\n      process.stdout.removeAllListeners('data');\n      process.stdin.removeAllListeners('error');\n      process.removeAllListeners('error');\n      process.removeAllListeners('exit');\n      process.kill('SIGINT');\n      var killTimeout = setTimeout(function () {\n        return process.kill('SIGKILL');\n      }, 8000);\n      process.once('close', function () {\n        clearTimeout(killTimeout);\n        resolve();\n      });\n    });\n  }; // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()\n  //   Receives a Swarm configuration object and a callback function. It then\n  //   checks if a local Swarm node is running. If no local Swarm is found, it\n  //   downloads the Swarm binaries to the dataDir (if not there), checksums,\n  //   starts the Swarm process and calls the callback function with an API\n  //   object using the local node. That callback must return a promise which\n  //   will resolve when it is done using the API, so that this function can\n  //   close the Swarm process properly. Returns a promise that resolves when the\n  //   user is done with the API and the Swarm process is closed.\n  //   TODO: check if Swarm process is already running (improve `isAvailable`)\n\n\n  var local = function local(swarmSetup) {\n    return function (useAPI) {\n      return _isAvailable(\"http://localhost:8500\").then(function (isAvailable) {\n        return isAvailable ? useAPI(at(\"http://localhost:8500\")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {\n          return (swarmSetup.onProgress || function () {})(data.length);\n        }).then(function () {\n          return startProcess(swarmSetup);\n        }).then(function (process) {\n          return useAPI(at(\"http://localhost:8500\")).then(function () {\n            return process;\n          });\n        }).then(stopProcess);\n      });\n    };\n  }; // String ~> Promise Bool\n  //   Returns true if Swarm is available on `url`.\n  //   Perfoms a test upload to determine that.\n  //   TODO: improve this?\n\n\n  var _isAvailable = function isAvailable(swarmUrl) {\n    var testFile = \"test\";\n    var testHash = \"c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7\";\n    return uploadData(swarmUrl)(testFile).then(function (hash) {\n      return hash === testHash;\n    })[\"catch\"](function () {\n      return false;\n    });\n  }; // String -> String ~> Promise Bool\n  //   Returns a Promise which is true if that Swarm address is a directory.\n  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.\n  //   TODO: improve this?\n\n\n  var isDirectory = function isDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadData(swarmUrl)(hash).then(function (data) {\n        try {\n          return !!JSON.parse(toString(data)).entries;\n        } catch (e) {\n          return false;\n        }\n      });\n    };\n  }; // Uncurries a function; used to allow the f(x,y,z) style on exports.\n\n\n  var uncurry = function uncurry(f) {\n    return function (a, b, c, d, e) {\n      var p; // Hardcoded because efficiency (`arguments` is very slow).\n\n      if (typeof a !== \"undefined\") p = f(a);\n      if (typeof b !== \"undefined\") p = f(b);\n      if (typeof c !== \"undefined\") p = f(c);\n      if (typeof d !== \"undefined\") p = f(d);\n      if (typeof e !== \"undefined\") p = f(e);\n      return p;\n    };\n  }; // () -> Promise Bool\n  //   Not sure how to mock Swarm to test it properly. Ideas?\n\n\n  var test = function test() {\n    return Promise.resolve(true);\n  }; // Uint8Array -> String\n\n\n  var toString = function toString(uint8Array) {\n    return bytes.toString(bytes.fromUint8Array(uint8Array));\n  }; // String -> Uint8Array\n\n\n  var fromString = function fromString(string) {\n    return bytes.toUint8Array(bytes.fromString(string));\n  }; // String -> SwarmAPI\n  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.\n\n\n  var at = function at(swarmUrl) {\n    return {\n      download: function download(hash, path) {\n        return _download(swarmUrl)(hash)(path);\n      },\n      downloadData: uncurry(downloadData(swarmUrl)),\n      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),\n      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),\n      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),\n      downloadEntries: uncurry(downloadEntries(swarmUrl)),\n      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),\n      isAvailable: function isAvailable() {\n        return _isAvailable(swarmUrl);\n      },\n      upload: function upload(arg) {\n        return _upload(swarmUrl)(arg);\n      },\n      uploadData: uncurry(uploadData(swarmUrl)),\n      uploadFile: uncurry(uploadFile(swarmUrl)),\n      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),\n      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),\n      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),\n      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),\n      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),\n      pick: pick,\n      hash: hash,\n      fromString: fromString,\n      toString: toString\n    };\n  };\n\n  return {\n    at: at,\n    local: local,\n    download: _download,\n    downloadBinary: downloadBinary,\n    downloadData: downloadData,\n    downloadDataToDisk: downloadDataToDisk,\n    downloadDirectory: downloadDirectory,\n    downloadDirectoryToDisk: downloadDirectoryToDisk,\n    downloadEntries: downloadEntries,\n    downloadRoutes: downloadRoutes,\n    isAvailable: _isAvailable,\n    startProcess: startProcess,\n    stopProcess: stopProcess,\n    upload: _upload,\n    uploadData: uploadData,\n    uploadDataFromDisk: uploadDataFromDisk,\n    uploadFile: uploadFile,\n    uploadFileFromDisk: uploadFileFromDisk,\n    uploadDirectory: uploadDirectory,\n    uploadDirectoryFromDisk: uploadDirectoryFromDisk,\n    uploadToManifest: uploadToManifest,\n    pick: pick,\n    hash: hash,\n    fromString: fromString,\n    toString: toString\n  };\n};","map":{"version":3,"sources":["/Users/matt/Projects/sushiswap-frontend/node_modules/swarm-js/lib/swarm.js"],"names":["module","exports","_ref","fs","files","os","path","child_process","mimetype","defaultArchives","request","downloadUrl","bytes","hash","pick","impureInsert","key","val","map","toMap","keys","vals","i","l","length","merge","a","b","_key","equals","rawUrl","swarmUrl","concat","downloadData","Promise","resolve","reject","responseType","err","arrayBuffer","response","statusCode","Error","Uint8Array","downloadEntries","search","routes","format","entry","type","contentType","downloadEntry","undefined","then","text","JSON","parse","toString","entries","all","downloadRoutes","Object","route","downloadDirectory","paths","hashs","types","datas","data","downloadDataToDisk","filePath","download","downloadDirectoryToDisk","dirPath","routingTable","downloads","join","push","uploadData","params","body","fromString","method","uploadToManifest","file","attempt","n","slashRoute","url","opt","headers","indexOf","e","uploadFile","uploadDirectory","uploadFileFromDisk","readFile","lookup","directory","uploadRoute","uploadToHash","reduce","uploadDataFromDisk","uploadDirectoryFromDisk","defaultPath","directoryTree","fullPaths","slice","_upload","upload","arg","kind","defaultFile","_download","isDirectory","isDir","downloadBinary","archives","system","platform","replace","arch","archive","archiveUrl","archiveMD5","binaryMD5","safeDownloadArchived","startProcess","swarmSetup","spawn","hasString","str","buffer","account","password","dataDir","ensApi","privateKey","STARTUP_TIMEOUT_SECS","WAITING_PASSWORD","STARTING","LISTENING","PASSWORD_PROMPT_HOOK","LISTENING_HOOK","state","swarmProcess","binPath","handleProcessOutput","setTimeout","stdin","write","clearTimeout","timeout","stdout","on","stderr","restart","error","stopProcess","process","removeAllListeners","kill","killTimeout","once","local","useAPI","_isAvailable","isAvailable","at","onData","onProgress","testFile","testHash","uncurry","f","c","d","p","test","uint8Array","fromUint8Array","string","toUint8Array"],"mappings":"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","sourcesContent":["// TODO: this is a temporary fix to hide those libraries from the browser. A\n// slightly better long-term solution would be to split this file into two,\n// separating the functions that are used on Node.js from the functions that\n// are used only on the browser.\nmodule.exports = function (_ref) {\n  var fs = _ref.fs,\n      files = _ref.files,\n      os = _ref.os,\n      path = _ref.path,\n      child_process = _ref.child_process,\n      mimetype = _ref.mimetype,\n      defaultArchives = _ref.defaultArchives,\n      request = _ref.request,\n      downloadUrl = _ref.downloadUrl,\n      bytes = _ref.bytes,\n      hash = _ref.hash,\n      pick = _ref.pick;\n\n  // ∀ a . String -> JSON -> Map String a -o Map String a\n  //   Inserts a key/val pair in an object impurely.\n  var impureInsert = function impureInsert(key) {\n    return function (val) {\n      return function (map) {\n        return map[key] = val, map;\n      };\n    };\n  }; // String -> JSON -> Map String JSON\n  //   Merges an array of keys and an array of vals into an object.\n\n\n  var toMap = function toMap(keys) {\n    return function (vals) {\n      var map = {};\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        map[keys[i]] = vals[i];\n      }\n\n      return map;\n    };\n  }; // ∀ a . Map String a -> Map String a -> Map String a\n  //   Merges two maps into one.\n\n\n  var merge = function merge(a) {\n    return function (b) {\n      var map = {};\n\n      for (var key in a) {\n        map[key] = a[key];\n      }\n\n      for (var _key in b) {\n        map[_key] = b[_key];\n      }\n\n      return map;\n    };\n  }; // ∀ a . [a] -> [a] -> Bool\n\n\n  var equals = function equals(a) {\n    return function (b) {\n      if (a.length !== b.length) {\n        return false;\n      } else {\n        for (var i = 0, l = a.length; i < l; ++i) {\n          if (a[i] !== b[i]) return false;\n        }\n      }\n\n      return true;\n    };\n  }; // String -> String -> String\n\n\n  var rawUrl = function rawUrl(swarmUrl) {\n    return function (hash) {\n      return \"\".concat(swarmUrl, \"/bzz-raw:/\").concat(hash);\n    };\n  }; // String -> String -> Promise Uint8Array\n  //   Gets the raw contents of a Swarm hash address.\n\n\n  var downloadData = function downloadData(swarmUrl) {\n    return function (hash) {\n      return new Promise(function (resolve, reject) {\n        request(rawUrl(swarmUrl)(hash), {\n          responseType: \"arraybuffer\"\n        }, function (err, arrayBuffer, response) {\n          if (err) {\n            return reject(err);\n          }\n\n          if (response.statusCode >= 400) {\n            return reject(new Error(\"Error \".concat(response.statusCode, \".\")));\n          }\n\n          return resolve(new Uint8Array(arrayBuffer));\n        });\n      });\n    };\n  }; // type Entry = {\"type\": String, \"hash\": String}\n  // type File = {\"type\": String, \"data\": Uint8Array}\n  // String -> String -> Promise (Map String Entry)\n  //   Solves the manifest of a Swarm address recursively.\n  //   Returns a map from full paths to entries.\n\n\n  var downloadEntries = function downloadEntries(swarmUrl) {\n    return function (hash) {\n      var search = function search(hash) {\n        return function (path) {\n          return function (routes) {\n            // Formats an entry to the Swarm.js type.\n            var format = function format(entry) {\n              return {\n                type: entry.contentType,\n                hash: entry.hash\n              };\n            }; // To download a single entry:\n            //   if type is bzz-manifest, go deeper\n            //   if not, add it to the routing table\n\n\n            var downloadEntry = function downloadEntry(entry) {\n              if (entry.path === undefined) {\n                return Promise.resolve();\n              } else {\n                return entry.contentType === \"application/bzz-manifest+json\" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));\n              }\n            }; // Downloads the initial manifest and then each entry.\n\n\n            return downloadData(swarmUrl)(hash).then(function (text) {\n              return JSON.parse(toString(text)).entries;\n            }).then(function (entries) {\n              return Promise.all(entries.map(downloadEntry));\n            }).then(function () {\n              return routes;\n            });\n          };\n        };\n      };\n\n      return search(hash)(\"\")({});\n    };\n  }; // String -> String -> Promise (Map String String)\n  //   Same as `downloadEntries`, but returns only hashes (no types).\n\n\n  var downloadRoutes = function downloadRoutes(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {\n          return entries[route].hash;\n        }));\n      });\n    };\n  }; // String -> String -> Promise (Map String File)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectory = function downloadDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        var paths = Object.keys(entries);\n        var hashs = paths.map(function (path) {\n          return entries[path].hash;\n        });\n        var types = paths.map(function (path) {\n          return entries[path].type;\n        });\n        var datas = hashs.map(downloadData(swarmUrl));\n\n        var files = function files(datas) {\n          return datas.map(function (data, i) {\n            return {\n              type: types[i],\n              data: data\n            };\n          });\n        };\n\n        return Promise.all(datas).then(function (datas) {\n          return toMap(paths)(files(datas));\n        });\n      });\n    };\n  }; // String -> String -> String -> Promise String\n  //   Gets the raw contents of a Swarm hash address.\n  //   Returns a promise with the downloaded file path.\n\n\n  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {\n    return function (hash) {\n      return function (filePath) {\n        return files.download(rawUrl(swarmUrl)(hash))(filePath);\n      };\n    };\n  }; // String -> String -> String -> Promise (Map String String)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {\n    return function (hash) {\n      return function (dirPath) {\n        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {\n          var downloads = [];\n\n          for (var route in routingTable) {\n            if (route.length > 0) {\n              var filePath = path.join(dirPath, route);\n              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));\n            }\n\n            ;\n          }\n\n          ;\n          return Promise.all(downloads).then(function () {\n            return dirPath;\n          });\n        });\n      };\n    };\n  }; // String -> Uint8Array -> Promise String\n  //   Uploads raw data to Swarm.\n  //   Returns a promise with the uploaded hash.\n\n\n  var uploadData = function uploadData(swarmUrl) {\n    return function (data) {\n      return new Promise(function (resolve, reject) {\n        var params = {\n          body: typeof data === \"string\" ? fromString(data) : data,\n          method: \"POST\"\n        };\n        request(\"\".concat(swarmUrl, \"/bzz-raw:/\"), params, function (err, data) {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(data);\n        });\n      });\n    };\n  }; // String -> String -> String -> File -> Promise String\n  //   Uploads a file to the Swarm manifest at a given hash, under a specific\n  //   route. Returns a promise containing the uploaded hash.\n  //   FIXME: for some reasons Swarm-Gateways is sometimes returning\n  //   error 404 (bad request), so we retry up to 3 times. Why?\n\n\n  var uploadToManifest = function uploadToManifest(swarmUrl) {\n    return function (hash) {\n      return function (route) {\n        return function (file) {\n          var attempt = function attempt(n) {\n            var slashRoute = route[0] === \"/\" ? route : \"/\" + route;\n            var url = \"\".concat(swarmUrl, \"/bzz:/\").concat(hash).concat(slashRoute);\n            var opt = {\n              method: \"PUT\",\n              headers: {\n                \"Content-Type\": file.type\n              },\n              body: file.data\n            };\n            return new Promise(function (resolve, reject) {\n              request(url, opt, function (err, data) {\n                if (err) {\n                  return reject(err);\n                }\n\n                if (data.indexOf(\"error\") !== -1) {\n                  return reject(data);\n                }\n\n                return resolve(data);\n              });\n            })[\"catch\"](function (e) {\n              return n > 0 && attempt(n - 1);\n            });\n          };\n\n          return attempt(3);\n        };\n      };\n    };\n  }; // String -> {type: String, data: Uint8Array} -> Promise String\n\n\n  var uploadFile = function uploadFile(swarmUrl) {\n    return function (file) {\n      return uploadDirectory(swarmUrl)({\n        \"\": file\n      });\n    };\n  }; // String -> String -> Promise String\n\n\n  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(function (data) {\n        return uploadFile(swarmUrl)({\n          type: mimetype.lookup(filePath),\n          data: data\n        });\n      });\n    };\n  }; // String -> Map String File -> Promise String\n  //   Uploads a directory to Swarm. The directory is\n  //   represented as a map of routes and files.\n  //   A default path is encoded by having a \"\" route.\n\n\n  var uploadDirectory = function uploadDirectory(swarmUrl) {\n    return function (directory) {\n      return uploadData(swarmUrl)(\"{}\").then(function (hash) {\n        var uploadRoute = function uploadRoute(route) {\n          return function (hash) {\n            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);\n          };\n        };\n\n        var uploadToHash = function uploadToHash(hash, route) {\n          return hash.then(uploadRoute(route));\n        };\n\n        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));\n      });\n    };\n  }; // String -> Promise String\n\n\n  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(uploadData(swarmUrl));\n    };\n  }; // String -> Nullable String -> String -> Promise String\n\n\n  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {\n    return function (defaultPath) {\n      return function (dirPath) {\n        return files.directoryTree(dirPath).then(function (fullPaths) {\n          return Promise.all(fullPaths.map(function (path) {\n            return fs.readFile(path);\n          })).then(function (datas) {\n            var paths = fullPaths.map(function (path) {\n              return path.slice(dirPath.length);\n            });\n            var types = fullPaths.map(function (path) {\n              return mimetype.lookup(path) || \"text/plain\";\n            });\n            return toMap(paths)(datas.map(function (data, i) {\n              return {\n                type: types[i],\n                data: data\n              };\n            }));\n          });\n        }).then(function (directory) {\n          return merge(defaultPath ? {\n            \"\": directory[defaultPath]\n          } : {})(directory);\n        }).then(uploadDirectory(swarmUrl));\n      };\n    };\n  }; // String -> UploadInfo -> Promise String\n  //   Simplified multi-type upload which calls the correct\n  //   one based on the type of the argument given.\n\n\n  var _upload = function upload(swarmUrl) {\n    return function (arg) {\n      // Upload raw data from browser\n      if (arg.pick === \"data\") {\n        return pick.data().then(uploadData(swarmUrl)); // Upload a file from browser\n      } else if (arg.pick === \"file\") {\n        return pick.file().then(uploadFile(swarmUrl)); // Upload a directory from browser\n      } else if (arg.pick === \"directory\") {\n        return pick.directory().then(uploadDirectory(swarmUrl)); // Upload directory/file from disk\n      } else if (arg.path) {\n        switch (arg.kind) {\n          case \"data\":\n            return uploadDataFromDisk(swarmUrl)(arg.path);\n\n          case \"file\":\n            return uploadFileFromDisk(swarmUrl)(arg.path);\n\n          case \"directory\":\n            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);\n        }\n\n        ; // Upload UTF-8 string or raw data (buffer)\n      } else if (arg.length || typeof arg === \"string\") {\n        return uploadData(swarmUrl)(arg); // Upload directory with JSON\n      } else if (arg instanceof Object) {\n        return uploadDirectory(swarmUrl)(arg);\n      }\n\n      return Promise.reject(new Error(\"Bad arguments\"));\n    };\n  }; // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)\n  //   Simplified multi-type download which calls the correct function based on\n  //   the type of the argument given, and on whether the Swwarm address has a\n  //   directory or a file.\n\n\n  var _download = function download(swarmUrl) {\n    return function (hash) {\n      return function (path) {\n        return isDirectory(swarmUrl)(hash).then(function (isDir) {\n          if (isDir) {\n            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);\n          } else {\n            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);\n          }\n        });\n      };\n    };\n  }; // String -> Promise String\n  //   Downloads the Swarm binaries into a path. Returns a promise that only\n  //   resolves when the exact Swarm file is there, and verified to be correct.\n  //   If it was already there to begin with, skips the download.\n\n\n  var downloadBinary = function downloadBinary(path, archives) {\n    var system = os.platform().replace(\"win32\", \"windows\") + \"-\" + (os.arch() === \"x64\" ? \"amd64\" : \"386\");\n    var archive = (archives || defaultArchives)[system];\n    var archiveUrl = downloadUrl + archive.archive + \".tar.gz\";\n    var archiveMD5 = archive.archiveMD5;\n    var binaryMD5 = archive.binaryMD5;\n    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);\n  }; // type SwarmSetup = {\n  //   account : String,\n  //   password : String,\n  //   dataDir : String,\n  //   binPath : String,\n  //   ensApi : String,\n  //   onDownloadProgress : Number ~> (),\n  //   archives : [{\n  //     archive: String,\n  //     binaryMD5: String,\n  //     archiveMD5: String\n  //   }]\n  // }\n  // SwarmSetup ~> Promise Process\n  //   Starts the Swarm process.\n\n\n  var startProcess = function startProcess(swarmSetup) {\n    return new Promise(function (resolve, reject) {\n      var spawn = child_process.spawn;\n\n      var hasString = function hasString(str) {\n        return function (buffer) {\n          return ('' + buffer).indexOf(str) !== -1;\n        };\n      };\n\n      var account = swarmSetup.account,\n          password = swarmSetup.password,\n          dataDir = swarmSetup.dataDir,\n          ensApi = swarmSetup.ensApi,\n          privateKey = swarmSetup.privateKey;\n      var STARTUP_TIMEOUT_SECS = 3;\n      var WAITING_PASSWORD = 0;\n      var STARTING = 1;\n      var LISTENING = 2;\n      var PASSWORD_PROMPT_HOOK = \"Passphrase\";\n      var LISTENING_HOOK = \"Swarm http proxy started\";\n      var state = WAITING_PASSWORD;\n      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);\n\n      var handleProcessOutput = function handleProcessOutput(data) {\n        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {\n          setTimeout(function () {\n            state = STARTING;\n            swarmProcess.stdin.write(password + '\\n');\n          }, 500);\n        } else if (hasString(LISTENING_HOOK)(data)) {\n          state = LISTENING;\n          clearTimeout(timeout);\n          resolve(swarmProcess);\n        }\n      };\n\n      swarmProcess.stdout.on('data', handleProcessOutput);\n      swarmProcess.stderr.on('data', handleProcessOutput); //swarmProcess.on('close', () => setTimeout(restart, 2000));\n\n      var restart = function restart() {\n        return startProcess(swarmSetup).then(resolve)[\"catch\"](reject);\n      };\n\n      var error = function error() {\n        return reject(new Error(\"Couldn't start swarm process.\"));\n      };\n\n      var timeout = setTimeout(error, 20000);\n    });\n  }; // Process ~> Promise ()\n  //   Stops the Swarm process.\n\n\n  var stopProcess = function stopProcess(process) {\n    return new Promise(function (resolve, reject) {\n      process.stderr.removeAllListeners('data');\n      process.stdout.removeAllListeners('data');\n      process.stdin.removeAllListeners('error');\n      process.removeAllListeners('error');\n      process.removeAllListeners('exit');\n      process.kill('SIGINT');\n      var killTimeout = setTimeout(function () {\n        return process.kill('SIGKILL');\n      }, 8000);\n      process.once('close', function () {\n        clearTimeout(killTimeout);\n        resolve();\n      });\n    });\n  }; // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()\n  //   Receives a Swarm configuration object and a callback function. It then\n  //   checks if a local Swarm node is running. If no local Swarm is found, it\n  //   downloads the Swarm binaries to the dataDir (if not there), checksums,\n  //   starts the Swarm process and calls the callback function with an API\n  //   object using the local node. That callback must return a promise which\n  //   will resolve when it is done using the API, so that this function can\n  //   close the Swarm process properly. Returns a promise that resolves when the\n  //   user is done with the API and the Swarm process is closed.\n  //   TODO: check if Swarm process is already running (improve `isAvailable`)\n\n\n  var local = function local(swarmSetup) {\n    return function (useAPI) {\n      return _isAvailable(\"http://localhost:8500\").then(function (isAvailable) {\n        return isAvailable ? useAPI(at(\"http://localhost:8500\")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {\n          return (swarmSetup.onProgress || function () {})(data.length);\n        }).then(function () {\n          return startProcess(swarmSetup);\n        }).then(function (process) {\n          return useAPI(at(\"http://localhost:8500\")).then(function () {\n            return process;\n          });\n        }).then(stopProcess);\n      });\n    };\n  }; // String ~> Promise Bool\n  //   Returns true if Swarm is available on `url`.\n  //   Perfoms a test upload to determine that.\n  //   TODO: improve this?\n\n\n  var _isAvailable = function isAvailable(swarmUrl) {\n    var testFile = \"test\";\n    var testHash = \"c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7\";\n    return uploadData(swarmUrl)(testFile).then(function (hash) {\n      return hash === testHash;\n    })[\"catch\"](function () {\n      return false;\n    });\n  }; // String -> String ~> Promise Bool\n  //   Returns a Promise which is true if that Swarm address is a directory.\n  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.\n  //   TODO: improve this?\n\n\n  var isDirectory = function isDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadData(swarmUrl)(hash).then(function (data) {\n        try {\n          return !!JSON.parse(toString(data)).entries;\n        } catch (e) {\n          return false;\n        }\n      });\n    };\n  }; // Uncurries a function; used to allow the f(x,y,z) style on exports.\n\n\n  var uncurry = function uncurry(f) {\n    return function (a, b, c, d, e) {\n      var p; // Hardcoded because efficiency (`arguments` is very slow).\n\n      if (typeof a !== \"undefined\") p = f(a);\n      if (typeof b !== \"undefined\") p = f(b);\n      if (typeof c !== \"undefined\") p = f(c);\n      if (typeof d !== \"undefined\") p = f(d);\n      if (typeof e !== \"undefined\") p = f(e);\n      return p;\n    };\n  }; // () -> Promise Bool\n  //   Not sure how to mock Swarm to test it properly. Ideas?\n\n\n  var test = function test() {\n    return Promise.resolve(true);\n  }; // Uint8Array -> String\n\n\n  var toString = function toString(uint8Array) {\n    return bytes.toString(bytes.fromUint8Array(uint8Array));\n  }; // String -> Uint8Array\n\n\n  var fromString = function fromString(string) {\n    return bytes.toUint8Array(bytes.fromString(string));\n  }; // String -> SwarmAPI\n  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.\n\n\n  var at = function at(swarmUrl) {\n    return {\n      download: function download(hash, path) {\n        return _download(swarmUrl)(hash)(path);\n      },\n      downloadData: uncurry(downloadData(swarmUrl)),\n      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),\n      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),\n      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),\n      downloadEntries: uncurry(downloadEntries(swarmUrl)),\n      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),\n      isAvailable: function isAvailable() {\n        return _isAvailable(swarmUrl);\n      },\n      upload: function upload(arg) {\n        return _upload(swarmUrl)(arg);\n      },\n      uploadData: uncurry(uploadData(swarmUrl)),\n      uploadFile: uncurry(uploadFile(swarmUrl)),\n      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),\n      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),\n      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),\n      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),\n      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),\n      pick: pick,\n      hash: hash,\n      fromString: fromString,\n      toString: toString\n    };\n  };\n\n  return {\n    at: at,\n    local: local,\n    download: _download,\n    downloadBinary: downloadBinary,\n    downloadData: downloadData,\n    downloadDataToDisk: downloadDataToDisk,\n    downloadDirectory: downloadDirectory,\n    downloadDirectoryToDisk: downloadDirectoryToDisk,\n    downloadEntries: downloadEntries,\n    downloadRoutes: downloadRoutes,\n    isAvailable: _isAvailable,\n    startProcess: startProcess,\n    stopProcess: stopProcess,\n    upload: _upload,\n    uploadData: uploadData,\n    uploadDataFromDisk: uploadDataFromDisk,\n    uploadFile: uploadFile,\n    uploadFileFromDisk: uploadFileFromDisk,\n    uploadDirectory: uploadDirectory,\n    uploadDirectoryFromDisk: uploadDirectoryFromDisk,\n    uploadToManifest: uploadToManifest,\n    pick: pick,\n    hash: hash,\n    fromString: fromString,\n    toString: toString\n  };\n};"]},"metadata":{},"sourceType":"script"}