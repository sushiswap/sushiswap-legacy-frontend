{"ast":null,"code":"const keccakState = require('./keccak-state-unroll');\n\nfunction Keccak() {\n  // much faster than `new Array(50)`\n  this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  this.blockSize = null;\n  this.count = 0;\n  this.squeezing = false;\n}\n\nKeccak.prototype.initialize = function (rate, capacity) {\n  for (let i = 0; i < 50; ++i) this.state[i] = 0;\n\n  this.blockSize = rate / 8;\n  this.count = 0;\n  this.squeezing = false;\n};\n\nKeccak.prototype.absorb = function (data) {\n  for (let i = 0; i < data.length; ++i) {\n    this.state[~~(this.count / 4)] ^= data[i] << 8 * (this.count % 4);\n    this.count += 1;\n\n    if (this.count === this.blockSize) {\n      keccakState.p1600(this.state);\n      this.count = 0;\n    }\n  }\n};\n\nKeccak.prototype.absorbLastFewBits = function (bits) {\n  this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);\n  if ((bits & 0x80) !== 0 && this.count === this.blockSize - 1) keccakState.p1600(this.state);\n  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << 8 * ((this.blockSize - 1) % 4);\n  keccakState.p1600(this.state);\n  this.count = 0;\n  this.squeezing = true;\n};\n\nKeccak.prototype.squeeze = function (length) {\n  if (!this.squeezing) this.absorbLastFewBits(0x01);\n  const output = Buffer.alloc(length);\n\n  for (let i = 0; i < length; ++i) {\n    output[i] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 0xff;\n    this.count += 1;\n\n    if (this.count === this.blockSize) {\n      keccakState.p1600(this.state);\n      this.count = 0;\n    }\n  }\n\n  return output;\n};\n\nKeccak.prototype.copy = function (dest) {\n  for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i];\n\n  dest.blockSize = this.blockSize;\n  dest.count = this.count;\n  dest.squeezing = this.squeezing;\n};\n\nmodule.exports = Keccak;","map":{"version":3,"sources":["/Users/matt/Projects/sushiswap-frontend/node_modules/ethereum-cryptography/node_modules/keccak/lib/keccak.js"],"names":["keccakState","require","Keccak","state","blockSize","count","squeezing","prototype","initialize","rate","capacity","i","absorb","data","length","p1600","absorbLastFewBits","bits","squeeze","output","Buffer","alloc","copy","dest","module","exports"],"mappings":"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","sourcesContent":["const keccakState = require('./keccak-state-unroll')\n\nfunction Keccak () {\n  // much faster than `new Array(50)`\n  this.state = [\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0\n  ]\n\n  this.blockSize = null\n  this.count = 0\n  this.squeezing = false\n}\n\nKeccak.prototype.initialize = function (rate, capacity) {\n  for (let i = 0; i < 50; ++i) this.state[i] = 0\n  this.blockSize = rate / 8\n  this.count = 0\n  this.squeezing = false\n}\n\nKeccak.prototype.absorb = function (data) {\n  for (let i = 0; i < data.length; ++i) {\n    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))\n    this.count += 1\n    if (this.count === this.blockSize) {\n      keccakState.p1600(this.state)\n      this.count = 0\n    }\n  }\n}\n\nKeccak.prototype.absorbLastFewBits = function (bits) {\n  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))\n  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)\n  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))\n  keccakState.p1600(this.state)\n  this.count = 0\n  this.squeezing = true\n}\n\nKeccak.prototype.squeeze = function (length) {\n  if (!this.squeezing) this.absorbLastFewBits(0x01)\n\n  const output = Buffer.alloc(length)\n  for (let i = 0; i < length; ++i) {\n    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff\n    this.count += 1\n    if (this.count === this.blockSize) {\n      keccakState.p1600(this.state)\n      this.count = 0\n    }\n  }\n\n  return output\n}\n\nKeccak.prototype.copy = function (dest) {\n  for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i]\n  dest.blockSize = this.blockSize\n  dest.count = this.count\n  dest.squeezing = this.squeezing\n}\n\nmodule.exports = Keccak\n"]},"metadata":{},"sourceType":"script"}